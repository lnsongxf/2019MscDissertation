#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jul 12 19:34:26 2019

@author: valler
"""
from __future__ import division
import pandas as pd
from pandas import Series, DataFrame

from numpy.random import randn
import numpy as np
import matplotlib.pyplot as plt




'''
close_px_all = pd.read_csv('stock_px.csv', parse_dates=True, index_col=0)

close_px = close_px_all[['AAPL', 'MSFT', 'XOM']]

close_px = close_px.resample('B', fill_method='ffill').ffill()#only select working days

#close_px.info()

#several plotting sentences

#close_px['AAPL'].plot()# plot all data for aapl
#close_px.ix['2009'].plot() # 2009's data for3 firms 
#close_px['AAPL'].ix['01-2011':'03-2011'].plot()# Apple's data from2011.01-2011.03


#transfer the data into monthly data and plot
appl_q = close_px['AAPL'].resample('Q-DEC', fill_method='ffill').ffill()
appl_q.ix['2009':].plot() #平滑性有了很大的上涨

#rolling windows
close_px.AAPL.plot()
close_px.AAPL.rolling(250).mean().plot()#250 means: the window only select the fore 250days' mean 

#Exponentially weighted windows ewm
fig, axes = plt.subplots(nrows=2, ncols=1, sharex=True, sharey=True,
                         figsize=(12, 7))

aapl_px = close_px.AAPL['2005':'2009']
ma60 = aapl_px.rolling(60, min_periods=50).mean()
ewma60 =aapl_px.ewm(span=60).mean()
print(ewma60)

#Graph3
aapl_px.plot(style='k-', ax=axes[0])
ma60.plot(style='k--', ax=axes[0])
aapl_px.plot(style='k-', ax=axes[1])
ewma60.plot(style='k--', ax=axes[1])
axes[0].set_title('Simple MA')
axes[1].set_title('Exponentially-weighted MA')



#calculate correlation between Apple and SP500
close_px
spx_px = close_px_all['SPX']

spx_rets = spx_px / spx_px.shift(1) - 1
returns = close_px.pct_change() # return of SP500

Appl=returns.AAPL #return of Apple

#Graph2 plot the corr between Apple and SP500
corr = Appl.rolling(125, min_periods=100).corr(spx_rets)
corr.plot()

#Graph1 plot all the corr 
corr1=returns.rolling(125, min_periods=100).corr(spx_rets)
corr1.plot()

'''

#A Sample analysis

discfile = 'arima_data.xls'
forecastnum = 5

#读取数据，指定日期列为指标，Pandas自动将“日期”列识别为Datetime格式
data = pd.read_excel(discfile, index_col = u'日期')
data = pd.DataFrame(data,dtype=np.float64)
'''
#time series graph
plt.rcParams['font.sans-serif'] = ['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False #用来正常显示负号
data.plot()
plt.show()

#acf 
from statsmodels.graphics.tsaplots import plot_acf
plot_acf(data).show()

#stationary test
from statsmodels.tsa.stattools import adfuller as ADF
print( ADF(data[u'销量']))
'''
#Result after difference
D_data = data.diff().dropna() #get rid of the lack number
D_data.columns = [u'销量差分']
D_data.plot() #time series graph
plt.show()
#plot_acf(D_data).show() #acf
from statsmodels.graphics.tsaplots import plot_pacf
#plot_pacf(D_data).show() #pacf
#print(ADF(D_data[u'销量差分']))#平稳性检测

#white noise test
from statsmodels.stats.diagnostic import acorr_ljungbox
print(acorr_ljungbox(D_data, lags=1)) #返回统计量和p值, if statistic>cv, reject H0, not a white noise

from statsmodels.tsa.arima_model import ARIMA


#decide p,q
pmax = int(len(D_data)/10) #suppose p,q < length/10
qmax = int(len(D_data)/10) #suppose p,q < length/10
bic_matrix = [] #bic matrix
for p in range(pmax+1):
  tmp = []
  for q in range(qmax+1):
    try: 
      tmp.append(ARIMA(data, (p,1,q)).fit().bic)
    except:
      tmp.append(None)
  bic_matrix.append(tmp)

bic_matrix = pd.DataFrame(bic_matrix) #find the minimum 

p,q = bic_matrix.stack().idxmin() #先用stack展平，然后用idxmin找出最小值位置。
print(u'BIC最小的p值和q值为：%s、%s' %(p,q)) 

model = ARIMA(data, (0,1,1)).fit() #ARIMA(0, 1, 1)¥ model
print('modelsummary!!') #model report
print(model.summary())

print(model.forecast(5))



